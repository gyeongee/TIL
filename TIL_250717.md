### 이진분류 심층신경망
#### torch.from_numpy() : numpy를 tensor로 변형
#### tensor.numpy() : tensor를 numpy로 변형
``` python
# 유방암 데이터 사용
from sklearn.datasets import load_breast_cancer
cancer = load_breast_cancer()
df = pd.DataFrame(cancer.data, columns = cancer.feature_names)
df['class'] = cancer.target

# 넘파이를 Float32 타입의 PyTorch Tensor로 변환
data = torch.from_numpy(df.values).float()
X = data[:,:-1]
### 2차원으로 출력하기 위해 -1 뒤에 : 붙이기!!
y = data[:,-1:]

# 데이터 분리
X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=5)

X_train,X_valid, y_train,y_valid = train_test_split(X_train,y_train,test_size=0.25,random_state=5)

# 스케일링 진행
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()

# scaler 학습을 위해 넘파이형으로 변환
scaler.fit(X_train.numpy())
# 넘파이 형태로 변환하여 transform해주고 텐서형으로 변환 후 Float32 타입의 PyTorch Tensor로 변환
X_train = torch.from_numpy(scaler.transform(X_train.numpy())).float()
X_valid=torch.from_numpy(scaler.transform(X_valid.numpy())).float()
X_test=torch.from_numpy(scaler.transform(X_test.numpy())).float()

```
### 신경망 구성
``` python
# 신경망 구성: 입력 차원과 출력 차원을 받아 다층 퍼셉트론 구성
class MyModel(nn.Module):
  def __init__(self,input_dim, output_dim):
    # 입력 및 출력 차원 정보 저장
    self.input_dim = input_dim
    self.output_dim = output_dim
    super().__init__()

    self.linear1 = nn.Linear(input_dim, 25)
    self.linear2 = nn.Linear(25, 20)
    self.linear3 = nn.Linear(20, 15)
    self.linear4 = nn.Linear(15, 10)
    self.linear5 = nn.Linear(10, 5)
    self.linear6 = nn.Linear(5, output_dim)

    #  은닉층에서 사용할 ReLU 활성화 함수
    self.act_relu= nn.ReLU()
    # 출력층에서 사용할 Sigmoid 함수 (이진 분류의 경우)
    self.act_sigmoid=nn.Sigmoid()

# 입력 x를 받아 순전파 예측을 수행하는 함수
  def forward(self,x):
    h1 = self.act_relu(self.linear1(x))
    h2 = self.act_relu(self.linear2(h1))
    h3 = self.act_relu(self.linear3(h2))
    h4 = self.act_relu(self.linear4(h3))
    h5 = self.act_relu(self.linear5(h4))
    #  최종 출력은 sigmoid를 적용하여 0~1 사이 값 반환 (이진 분류)
    y = self.act_sigmoid(self.linear6(h5))
    return y

# 모델 인스턴스 생성
model1 = MyModel(X_train.size(-1), y_train.size(-1))
```

### # Sequential 사용하여 신경망 구성
``` python
# Sequential 사용(뼈대를 사용한 신경망 구성)
model2 = nn.Sequential(
    nn.Linear(X_train.size(-1),25),
    nn.ReLU(),
    nn.Linear(25, 20),
    nn.ReLU(),
    nn.Linear(20, 15),
    nn.ReLU(),
    nn.Linear(15, 10),
    nn.ReLU(),
    nn.Linear(10, 5),
    nn.ReLU(),
    nn.Linear(5, y_train.size(-1)),
    # 이진분류 출력층 시그모이드 활성화가 연결됨, 0~1(확률정보)
    nn.Sigmoid(),

)

# 최적화 
optimizer = optim.Adam(model2.parameters())

for X_i, y_i in zip(X_,y_):
    # 예측값 생성
    pred_y_i= model2(X_i)
    # sigmoid를 적용했기 때문에 binary_cross_entropy() 사용
    loss = F.binary_cross_entropy(pred_y_i, y_i)

    optimizer.zero_grad()
    loss.backward()
    optimizer.step()
    ```