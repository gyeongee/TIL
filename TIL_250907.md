1.1 식별연산
주소 비교 연산자
is : 피연산자들의 객체 메모리의 위치(주소)가 같다면 참(True)
그렇지 않으면 거짓(False)을 반환
is not : 피연산자들의 객체 메모리의 위치(주소)가 다르다면 참(True)
그렇지 않으면 거짓(False)을 반환
 coffee = "Brand"
orange = "Brand"

print(coffee is orange)
print(coffee == orange)

[ 결과 ]
True
True
파이썬의 문자열 캐싱(interning)

작은 문자열이나 식별자 형태의 문자열은 파이썬 내부에서 캐싱됩니다.

같은 문자열은 한 번만 메모리에 저장되고,
동일한 문자열을 다시 할당하면 같은 주소를 가리키게 됨.

※ 주의

숫자나 짧은 문자열은 캐싱되지만, 긴 문자열이나 런타임에 생성되는 문자열은 항상 캐싱되지 않을 수 있음.

a = "a very long string that might not be interned"
b = "a very long string that might not be interned"
print(a is b)  

[ 결과 ]
False
= (할당 연산자)
값을 변수에 할당할 때 사용
오른쪽 값을 왼쪽 변수에 저장
==(동등 비교 연산자)
두 값이 같은지 비교할 때 사용
a = [1, 2, 3]
b = [1, 2, 3]
c = a # c=[1,2,3]

print('a == b', a == b)
print('a == c', a == c)
print('a is b', a is b)
print('a is c', a is c)

[ 결과 ]
a == b True
a == c True
a is b False
a is c True
※ 주의
배열과 같은 객체는 문자열과 달리 새로 생성할 때 새로운 주소에 담음
값은 동일하더라도 다른 주소를 가짐

1.2 멤버 연산
in : 왼쪽 피연산자가 오른쪽 피연산자 배열에 포함되어 있으면 참(True)을 반환
그렇지 않으면 거짓(False)를 반환
not in : 왼쪽 피연산자가 오른쪽 피연산자 배열에 포함되어 있지 않으면 참(True)을 반환
그렇지 않으면 거짓(False)를 반환
a=[1, 2, 3, 4]
b=[1, 2, 3, 4]
c = [[1,2,3,4],1,2,3,4]

print(a==b, a is b, a in b, a in c)

[ 결과 ]
True False False True
※ a in b 가 False인 이유
b의 요소는 1,2,3,4
리스트 b 안에 리스트 [1,2,3,4]라는 요소가 없음

isin(), any()
Pandas의 메서드 함수
Series.isin([값1,값2,...])
각 요소가 특정 컬렉션에 있는지를 확인
반환값: True, False
df = pd.DataFrame({
    'fruits':['apple','banana'],
    'vegetable':['cucumber','tomato']
})
print('vegetable'in df) # 키 값 존재 여부
print(df.isin(['cucumber']))
print()
print(df.isin(['cucumber']).any(axis=1)) # 행별 존재 여부
print()
print(df.isin(['cucumber']).any().any()) # 전체 데이터프레임에서 존재 여부

[ 결과 ]
True
   fruits  vegetable
0   False       True
1   False      False

0     True
1    False
dtype: bool

True
※ any()는 특히 대소비교를 할 때 사용하면 sort보다 실행시간을 많이 줄일 수 있다. 예를 들어 어떤 수와 어떤 리스트의 원소들을 비교하는데 해당 수가 리스트 안의 max값보다 큰지만 알고 싶다고 하자. 이 때, sort를 사용한 뒤 비교하면 리스트를 모두 정렬하기 때문에 시간이 걸린다. 하지만 any를 쓰면 리스트 내에 해당 수보다 큰 수가 있기만 하면 바로 True를 return하고 끝내기 때문에 시간이 덜 걸린다.

sort는 전체를 정렬하느라 시간 복잡도가 𝑂 ( 𝑛 log ⁡ 𝑛 ) O(nlogn) 걸림

any는 조건을 만족하는 순간 바로 끝내기 때문에 최선의 경우 𝑂 ( 1 ) O(1)

sorted()로 구하기
li = [5,9,2,7,3,8,4]
x = 10

### 리스트를 정렬해서 max 값 확인
li_sorted = sorted(li)
max_value = li_sorted[-1]
any()로 구하기
10>9를 발견하자마자 True를 반환하고 반복문을 빠져나옴
만약, x보다 큰 값이 없으면 끝까지 탐색해야 하지만, 여전히 정렬보다 빠름
has_larger = any(x>y for y in li)
max()로 구하기
max_li = max(li)
sort(): O(n log n), 전체 정렬.

max(): O(n), 한 번만 훑어봄.

any(): 최선 O(1), 조건 만족 시 즉시 종료.

👉 조건에 맞는 값이 있으면 True만 알면 된다면 any()가 최고로 빠르다.

아래 표는 상황별로 어떤 방법이 더 효율적인지 정리한 것입니다.

상황	더 효율적인 방법
조건 만족 값이 리스트 앞/중간에 있을 때	✅ any() (빠르게 탈출)
조건 만족 값이 리스트 끝에 있거나 없을 때	✅ max()와 any() 둘 다 O(n)
조건이 단순히 "가장 큰 값과 비교"라면	✅ max() (구현이 매우 최적화되어 있음)
print(10 in (10, 20, 30))     # True → 10이 튜플 안에 있으므로
print([2] in (10, 20, 30) )    # False → 리스트 [2]는 튜플 안에 없으므로
print([1, 2] in (10, 20, 30))  # False → 리스트 [1,2]도 없으므로
print({10, 10, 10})  # {10} → 중복 제거되어 하나만 남음
a = {10, 10, 20}  
print(a)
print(10 in a)         # True → 10이 집합 안에 있음
print({10} in a)       # False → 집합 안에 집합이 들어있지 않음
print({10, 20} in a)  # False → 집합 안에 집합이 들어있지 않음
a = {'key':'value', 'key2':'value'}
print('key' in a)           # True → in은 기본적으로 **key**를 검사
print('value' in a)         # False → value는 검사하지 않음
print('value' in a.values())  # True
print(('key', 'key2') in a)  # False → 튜플이 key로 존재하지 않음
print({'key', 'key2'} in a.keys()) # False -> in 연산자는 딕셔너리의 개별 키만 확인
print(all(k in a for k in ['key', 'key2']))   # True, all(): 모든 키가 존재하
print({'key', 'key2'} in a)  # False → 집합이 key로 존재하지 않음
all(): 모든 키가 존재하는지 확인
print(all(k in a for k in ['key', 'key2']))   
any(): 하나라도 있는지 확인
print(any(k in a for k in ['key', 'key3']))