```
# 도구 생성
from langchain.tools import tool

@tool
def get_str_length(s:str) -> int :
  """문자열을 입력받아 문자열의 길이를 반환하는 도구"""
  return len(s)

get_str_length.invoke("Hello World")
```


- Agent & AgentExecutor를 이용해서 바인딩된 도구 실행하기
```
# tool_calling(도구 호출)이 가능한 에이전트 생성
from langchain.agents import create_tool_calling_agent
# 생성한 에이전트를 실행 가능한 객체로 생성
from langchain.agents import AgentExecutor

agent = create_tool_calling_agent(llm,tools,promt)

#handle_parsing_errors=True : 에러 메시지 출력
agent_executor = AgentExecutor(agent=agent,
                                tools=tools,
                                verbose=True,
                                handle_parsing_errors=True)

# 실행
result=agent_executor.invoke({"input":I am a boy'의 문자열 길이를 알려줘})
print(result["output"])
```

### typing 
 코드가 더 명확하게 “이 함수가 어떤 타입을 주고받는지” 표현

  - def search_news(query: str) -> List[Dict[str, str]]:
    - 1. query:str ->  함수의 입력 파라미터 query가 문자열(str)임을 의미
    - 2. List[Dict[str,str]]
       함수가 반환하는 값의 자료형 -> 딕셔너리 요소를 가진 리스트

  ex) search_news("삼성전자")  # query는 "삼성전자"라는 str

&#91;

  {"삼성전자": "삼성전자 관련 뉴스 제목1"},

  {"삼성전자": "삼성전자 관련 뉴스 제목2"}

&#93;


### langchain_teddynote
 LangChain을 활용하는 한국어 튜토리얼과 실습을 지원하기 위해 개발된 파이썬 라이브러리입니다. 이 라이브러리는 LangChain의 기능을 확장하고, 한국어 사용자들이 쉽게 활용할 수 있도록 다양한 유틸리티와 도구들을 제공합니다

### 이전 대화 내용 기억하기
- RunnableWithMessageHistory를 사용하여  AgentExecutor를 감싸줌
```
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain.tools import tool
from typing import List, Dict
from langchain_teddynote.tools import GoogleNews
from langchain.agents import create_tool_calling_agent
from langchain.agents import AgentExecutor

llm = ChatOpenAI(model="gpt-4o-mini"temperature=0)
prompt = ChatPromptTemplate.from_messages(
  [
      ("system", "당신은 강력한 에이전트입니다."),
      # 이전 대화 내용을 넣는 자리
      ("placeholder", "{chat_history}"),
      # 사용자의 새로운 질문/명령이 들어갈 자리
      ("human", "{input}"),
      # 에이전트가 생각하거나 도구를 호출한 흔적 등을 기록
      ("placeholder", "{agent_scratchpad}")
  ]
)


# 검색 도구 정의
@tool
def search_news(query:str) -> List[Dict[str,str]] :
    """키워드로 구글 뉴스를 검색하는 기능"""
    news_tools=GoogleNews()

    return news_tools.search_by_keyword(query,k=2)

# 도구 등록
tools=[search_news]

# agent 생성
agent = create_tool_calling_agent(llm,tools,prompt)

# agent_executor 생성
agent_executor = AgentExecutor(agent=agent,
                                tools=tools,
                                verbose=True,
                                handle_parsing_errors=True)
```
```
# 실행
agent_executor.invoke({"input":"광주광역시 오늘 날씨 어때 ?"})

# 결과

> Entering new AgentExecutor chain...

Invoking: `search_news` with `{'query': '광주광역시 오늘 날씨'}`


[{'url': 'https://news.google.com/rss/articles/CBMibEFVX3lxTE13dGxwN3U1a3BBRWd1YVloMzNsYlA3aTZtajNRWGdIQVBLanM3ektieTVPOWI4eDhpSjlObTUyODhKR044dkgzZWplSEphTk1TNS1zQ1hpX2NaT0l5RGU1NGRGVFJGODc2STVvYQ?oc=5', 'content': '[오늘의 광주·전남 날씨]주 중반 비 소식…기온 뚝 떨어지고 강풍 예보 - 남도일보'}, {'url': 'https://news.google.com/rss/articles/CBMiX0FVX3lxTFBWeUlHb0FGUzROenZjOGVwSlIzTk16UW4tR0NGS2trWmRndDd6M24xMV9YVUdPdWQ5M3otOEtJRXQyOUhtTnRnOUZnSDVJTVRDdkxLcm1EYUMySFRrTW53?oc=5', 'content': '[오늘의 날씨] 광주·전남(28일, 토)…무더위 속 최대 50㎜ 비 - 뉴스1'}]오늘 광주광역시는 비 소식이 있으며, 기온이 뚝 떨어지고 강풍이 예보되어 있습니다. 자세한 내용은 [남도일보](https://news.google.com/rss/articles/CBMibEFVX3lxTE13dGxwN3U1a3BBRWd1YVloMzNsYlA3aTZtajNRWGdIQVBLanM3ektieTVPOWI4eDhpSjlObTUyODhKR044dkgzZWplSEphTk1TNS1zQ1hpX2NaT0l5RGU1NGRGVFJGODc2STVvYQ?oc=5)와 [뉴스1](https://news.google.com/rss/articles/CBMiX0FVX3lxTFBWeUlHb0FGUzROenZjOGVwSlIzTk16UW4tR0NGS2trWmRndDd6M24xMV9YVUdPdWQ5M3otOEtJRXQyOUhtTnRnOUZnSDVJTVRDdkxLcm1EYUMySFRrTW53?oc=5)에서 확인하실 수 있습니다.

> Finished chain.
{'input': '광주광역시 오늘 날씨 어때 ?',
 'output': '오늘 광주광역시는 비 소식이 있으며, 기온이 뚝 떨어지고 강풍이 예보되어 있습니다. 자세한 내용은 [남도일보](https://news.google.com/rss/articles/CBMibEFVX3lxTE13dGxwN3U1a3BBRWd1YVloMzNsYlA3aTZtajNRWGdIQVBLanM3ektieTVPOWI4eDhpSjlObTUyODhKR044dkgzZWplSEphTk1TNS1zQ1hpX2NaT0l5RGU1NGRGVFJGODc2STVvYQ?oc=5)와 [뉴스1](https://news.google.com/rss/articles/CBMiX0FVX3lxTFBWeUlHb0FGUzROenZjOGVwSlIzTk16UW4tR0NGS2trWmRndDd6M24xMV9YVUdPdWQ5M3otOEtJRXQyOUhtTnRnOUZnSDVJTVRDdkxLcm1EYUMySFRrTW53?oc=5)에서 확인하실 수 있습니다.'}
```

- RunnableWithMessageHistory는 **대화 기록(Chat History)**을 저장하고 불러오는 기능을 제공

- 여러 사용자가 동시에 대화를 하거나, 같은 사용자도 여러 대화를 병렬로 진행할 수 있는데,
  그럴 때 대화 내용을 구분하기 위해 세션 id가 필요함

```
  # "s_id_001": 대화를 식별하는 고유 번호
  config={"configurable":{"session_id":"s_id_001"}}
```

get_session_history(session_ids) 함수가 이 id를 받아서:

처음 보는 id면 → 새로운 ChatMessageHistory()를 만들어 저장소(store)에 추가

이미 있는 id면 → 기존에 저장된 대화 내용을 불러옴

- 세션 id의 구조
user_123_session_1

user_123_session_2
→ 한 사용자가 여러 대화를 구분할 수 있음.

### AgentStreamParser()
stream()으로 흘러나오는 "에이전트 실행 단계 데이터(raw data)"를 사람이 이해하기 쉽게 가공(해석)하는 것을 의미합니다.

```
# 대화 내용 기억 공간 생성
from langchain_community.chat_message_histories import ChatMessageHistory
# 대화 내용 관리
from langchain_core.runnables.history import RunnableWithMessageHistory
# Agent의 실행 과정을 파싱
from langchain_teddynote.messages import AgentStreamParser

# 세션 id 저장
store = {}

# 세션 id를 기반으로 세션에 저장된 내용을 가져오는 함수
def get_session_history(session_ids) :
  # 세션 id 목록에 세션 id가 없다면 새로 저장소를 생성
  if session_ids not in store :
    store[session_ids] = ChatMessageHistory()

  # 세션 id의 내용을 반환
  return store[session_ids]

# 채팅 메시지 기록 기능이 추가된 에이전트 생성
agent_with_chat_history = RunnableWithMessageHistory(
    # 에이전트이름
    agent_executor,
    # 저장 위치 (세션 id)
    get_session_history,

    # 현재 질문을 담아두는 키값
    # 입력을 저장할 위치
    # 사용자가 보낸 메세지를 입력 딕셔너리에서 어떤 키로 찾을지 지정
    input_messages_key="input",

    # 이전 대화 기록들을 담는 키값
    # 챗팅 메시지를 저장할 위치
    # 이전 대화 기록을 불러오거나 저장할 때, 그 기록을 어떤 키에 담아서 LLM에 넘길지 정하는 역할
    history_messages_key="chat_history"
)

# 질의에 대한 응답을 스트리밍으로 출력 (세션 id 설정)
# stream() : 출력 내용을 단계적으로 표시
response = agent_with_chat_history.stream(
    {"input" : "안녕하세요! 저는 홍길동입니다 !"},
    # 대화 내용 (input + llm의 응답)을 저장할 세션 id 설정
    config={"configurable":{"session_id":"s_id_001"}}
)

# agent이 실행 결과를 출력
agent_stream_parser = AgentStreamParser()

for step in response :
  agent_stream_parser.process_agent_steps(step)

# 결과출력
> Entering new None chain...
안녕하세요, 홍길동님! 어떻게 도와드릴까요?

> Finished chain.
[최종 답변]
안녕하세요, 홍길동님! 어떻게 도와드릴까요?
```

- invoke() vs stream()
  
  stream()과 invoke()는 기본적으로 같은 역할을 하는데, 출력 방식만 다름

  - 공통점

    둘 다 Runnable (여기서는 RunnableWithMessageHistory) 객체를 실행해서 LLM 응답을 가져옴.

    입력 딕셔너리({"input": "...", ...})와 설정(config)을 받아서 결과를 반환.

  - 차이점

  1. invoke() : 최종 답변만 한 번에 출력
```
response = agent_with_chat_history.invoke(
    {"input": "안녕하세요!"},
    config={"configurable": {"session_id":"s_id_001"}}
)
print(response)
```

2. stream() : 진행 과정(토큰/스텝 단위)을 순차적으로 출력

예: LLM이 토큰 단위로 생성하는 답변을 실시간으로 전달받거나,
Agent가 툴을 호출하고 결과를 받는 과정을 순차적으로 확인 가능

```
response = agent_with_chat_history.stream(
    {"input": "안녕하세요!"},
    config={"configurable": {"session_id":"s_id_001"}}
)
for step in response:
    print(step)   # 단계별 결과

```

